"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/components/Map.tsx":
/*!********************************!*\
  !*** ./app/components/Map.tsx ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _data_healthcareCenters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/healthcareCenters */ \"(app-pages-browser)/./app/data/healthcareCenters.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n// Use memo to prevent unnecessary re-renders\nconst MapComponent = /*#__PURE__*/ _s((0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_c = _s(function MapComponent(param) {\n    let { responses, style, showHealthFacilities = true // Default to showing facilities\n     } = param;\n    _s();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const mapInstanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const markersRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const facilityMarkersRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const initialZoomRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(12);\n    const centerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [infoWindow, setInfoWindow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [showHealthFacilitiesState, setShowHealthFacilities] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(showHealthFacilities);\n    // Initialize map only once\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!mapRef.current || mapInstanceRef.current) return;\n        if (window.google && window.google.maps) {\n            console.log(\"Initializing map instance\");\n            const initialCenter = {\n                lat: 8.87,\n                lng: 7.22\n            }; // Centered on your healthcare facilities area\n            const initialZoom = 12;\n            mapInstanceRef.current = new window.google.maps.Map(mapRef.current, {\n                center: initialCenter,\n                zoom: initialZoom,\n                mapTypeId: window.google.maps.MapTypeId.ROADMAP\n            });\n            // Create info window instance\n            setInfoWindow(new google.maps.InfoWindow());\n            // Store initial settings\n            initialZoomRef.current = initialZoom;\n            centerRef.current = new google.maps.LatLng(initialCenter.lat, initialCenter.lng);\n            // Add listeners to store user map interactions\n            mapInstanceRef.current.addListener(\"zoom_changed\", ()=>{\n                if (mapInstanceRef.current) {\n                    initialZoomRef.current = mapInstanceRef.current.getZoom() || initialZoom;\n                }\n            });\n            mapInstanceRef.current.addListener(\"center_changed\", ()=>{\n                if (mapInstanceRef.current) {\n                    centerRef.current = mapInstanceRef.current.getCenter() || null;\n                }\n            });\n        }\n    }, []);\n    // Add healthcare facilities to the map\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!mapInstanceRef.current || !infoWindow || !showHealthFacilitiesState) return;\n        // Clear existing facility markers\n        facilityMarkersRef.current.forEach((marker)=>marker.setMap(null));\n        facilityMarkersRef.current = [];\n        // Custom icon for healthcare facilities\n        const healthFacilityIcon = {\n            url: \"/images/purp.png\",\n            scaledSize: new google.maps.Size(32, 32)\n        };\n        // Add healthcare facility markers\n        _data_healthcareCenters__WEBPACK_IMPORTED_MODULE_2__.healthcareCenters.forEach((facility)=>{\n            if (facility.latitude && facility.longitude) {\n                const marker = new google.maps.Marker({\n                    position: {\n                        lat: facility.latitude,\n                        lng: facility.longitude\n                    },\n                    map: mapInstanceRef.current,\n                    title: facility.name,\n                    icon: healthFacilityIcon,\n                    zIndex: 2\n                });\n                // Add click listener to show info about the facility\n                marker.addListener(\"click\", ()=>{\n                    const content = '\\n            <div style=\"padding: 10px; max-width: 300px;\">\\n              <h3 style=\"margin: 0 0 8px 0;\">'.concat(facility.name, '</h3>\\n              <p style=\"margin: 0 0 5px 0;\"><strong>Address:</strong> ').concat(facility.address, '</p>\\n              <p style=\"margin: 0 0 5px 0;\"><strong>Immunization Days:</strong> ').concat(facility.days_of_immunization, '</p>\\n              <p style=\"margin: 0 0 5px 0;\"><strong>Hours:</strong> ').concat(facility.hours_of_work, \"</p>\\n            </div>\\n          \");\n                    infoWindow.setContent(content);\n                    infoWindow.open(mapInstanceRef.current, marker);\n                });\n                facilityMarkersRef.current.push(marker);\n            }\n        });\n    }, [\n        showHealthFacilitiesState,\n        infoWindow\n    ]); // Only re-run when showHealthFacilitiesState changes\n    // Handle response markers separately when responses change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!mapInstanceRef.current || !responses || !infoWindow) return;\n        // Clear existing response markers\n        markersRef.current.forEach((marker)=>marker.setMap(null));\n        markersRef.current = [];\n        // Add new response markers\n        responses.forEach((response)=>{\n            if (response.latitude && response.longitude) {\n                // Create a marker for each response\n                const marker = new window.google.maps.Marker({\n                    position: {\n                        lat: response.latitude,\n                        lng: response.longitude\n                    },\n                    map: mapInstanceRef.current,\n                    title: \"Response \".concat(response.id),\n                    // Use a different color than health facilities\n                    icon: {\n                        path: google.maps.SymbolPath.CIRCLE,\n                        scale: 8,\n                        fillColor: \"#FF5722\",\n                        fillOpacity: 0.8,\n                        strokeWeight: 1,\n                        strokeColor: \"#FFFFFF\"\n                    },\n                    zIndex: 1 // Lower z-index than health facilities\n                });\n                // Add click listener to show info about the response\n                marker.addListener(\"click\", ()=>{\n                    const content = '\\n            <div style=\"padding: 10px; max-width: 200px;\">\\n              <h4 style=\"margin: 0 0 5px 0;\">Survey Response '.concat(response.id, '</h4>\\n              <p style=\"margin: 0 0 3px 0;\">Ready for vaccine: ').concat(response.ready_for_vaccine || \"Not specified\", \"</p>\\n              \").concat(response.cares_for_girl ? '<p style=\"margin: 0 0 3px 0;\">Cares for girl: Yes</p>' : \"\", \"\\n              \").concat(response.received_hpv_dose ? '<p style=\"margin: 0 0 3px 0;\">Received HPV dose: Yes</p>' : \"\", \"\\n              \").concat(response.joined_whatsapp ? '<p style=\"margin: 0 0 3px 0;\">Joined WhatsApp: Yes</p>' : \"\", \"\\n            </div>\\n          \");\n                    infoWindow.setContent(content);\n                    infoWindow.open(mapInstanceRef.current, marker);\n                });\n                markersRef.current.push(marker);\n            }\n        });\n        // Calculate bounds including both responses and visible healthcare facilities\n        const allVisibleMarkers = [\n            ...markersRef.current\n        ];\n        if (showHealthFacilitiesState) {\n            allVisibleMarkers.push(...facilityMarkersRef.current);\n        }\n        // Adjust bounds if we have multiple markers, but limit zoom\n        if (allVisibleMarkers.length > 1) {\n            const bounds = new window.google.maps.LatLngBounds();\n            allVisibleMarkers.forEach((marker)=>{\n                bounds.extend(marker.getPosition());\n            });\n            // Fit bounds but then check if zoom is too close\n            mapInstanceRef.current.fitBounds(bounds);\n            // Wait for fitBounds to complete (it's async)\n            setTimeout(()=>{\n                if (mapInstanceRef.current) {\n                    // If zoom is too close (higher number = closer zoom)\n                    const currentZoom = mapInstanceRef.current.getZoom() || 0;\n                    if (currentZoom > 15) {\n                        mapInstanceRef.current.setZoom(15); // Set a maximum zoom level\n                    }\n                }\n            }, 100);\n        } else if (allVisibleMarkers.length === 1) {\n            // For a single marker, center but use a fixed zoom\n            const position = allVisibleMarkers[0].getPosition();\n            if (position) {\n                mapInstanceRef.current.setCenter(position);\n                mapInstanceRef.current.setZoom(14); // Good zoom level for a single point\n            }\n        } else if (allVisibleMarkers.length === 0 && centerRef.current) {\n            mapInstanceRef.current.setCenter(centerRef.current);\n            mapInstanceRef.current.setZoom(initialZoomRef.current);\n        }\n    }, [\n        responses,\n        showHealthFacilitiesState,\n        infoWindow\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(FilterButtonNew, {\n                active: showHealthFacilitiesState,\n                onClick: ()=>setShowHealthFacilities(!showHealthFacilitiesState),\n                count: _data_healthcareCenters__WEBPACK_IMPORTED_MODULE_2__.healthcareCenters.length,\n                label: \"\".concat(showHealthFacilitiesState ? \"Hide\" : \"Show\", \" Health Facilities\")\n            }, void 0, false, {\n                fileName: \"/Users/drewbernard/Documents/Visual Studio/Engagement Map/next-maps-app/app/components/Map.tsx\",\n                lineNumber: 213,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: mapRef,\n                style: {\n                    width: \"100%\",\n                    height: \"100%\",\n                    ...style\n                }\n            }, void 0, false, {\n                fileName: \"/Users/drewbernard/Documents/Visual Studio/Engagement Map/next-maps-app/app/components/Map.tsx\",\n                lineNumber: 219,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}, \"qyi6CI1hocK+A0jnCrfbxmnToVE=\")), \"qyi6CI1hocK+A0jnCrfbxmnToVE=\");\n_c1 = MapComponent;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MapComponent);\nvar _c, _c1;\n$RefreshReg$(_c, \"MapComponent$memo\");\n$RefreshReg$(_c1, \"MapComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL01hcC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUUwRDtBQUNzQjtBQW1CaEYsNkNBQTZDO0FBQzdDLE1BQU1LLDZCQUFlRixHQUFBQSwyQ0FBSUEsU0FBQyxTQUFTRSxhQUFhLEtBSXJDO1FBSnFDLEVBQzlDQyxTQUFTLEVBQ1RDLEtBQUssRUFDTEMsdUJBQXVCLEtBQUssZ0NBQWdDO0lBQWpDLEVBQ2xCLEdBSnFDOztJQUs5QyxNQUFNQyxTQUFTUCw2Q0FBTUEsQ0FBaUI7SUFDdEMsTUFBTVEsaUJBQWlCUiw2Q0FBTUEsQ0FBeUI7SUFDdEQsTUFBTVMsYUFBYVQsNkNBQU1BLENBQXVCLEVBQUU7SUFDbEQsTUFBTVUscUJBQXFCViw2Q0FBTUEsQ0FBdUIsRUFBRTtJQUMxRCxNQUFNVyxpQkFBaUJYLDZDQUFNQSxDQUFTO0lBQ3RDLE1BQU1ZLFlBQVlaLDZDQUFNQSxDQUE0QjtJQUNwRCxNQUFNLENBQUNhLFlBQVlDLGNBQWMsR0FBR2hCLCtDQUFRQSxDQUFnQztJQUM1RSxNQUFNLENBQUNpQiwyQkFBMkJDLHdCQUF3QixHQUFHbEIsK0NBQVFBLENBQUNRO0lBRXRFLDJCQUEyQjtJQUMzQlAsZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUNRLE9BQU9VLE9BQU8sSUFBSVQsZUFBZVMsT0FBTyxFQUFFO1FBRS9DLElBQUlDLE9BQU9DLE1BQU0sSUFBSUQsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLEVBQUU7WUFDdkNDLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU1DLGdCQUFnQjtnQkFBRUMsS0FBSztnQkFBTUMsS0FBSztZQUFLLEdBQUcsOENBQThDO1lBQzlGLE1BQU1DLGNBQWM7WUFFcEJsQixlQUFlUyxPQUFPLEdBQUcsSUFBSUMsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLENBQUNPLEdBQUcsQ0FBQ3BCLE9BQU9VLE9BQU8sRUFBRTtnQkFDbEVXLFFBQVFMO2dCQUNSTSxNQUFNSDtnQkFDTkksV0FB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O2dCQUN4QzJFLE9BQU94RixzRUFBaUJBLENBQUMyRSxNQUFNO2dCQUMvQmMsT0FBTyxHQUErQyxPQUE1QzVFLDRCQUE0QixTQUFTLFFBQU87Ozs7OzswQkFFeEQsOERBQUM2RTtnQkFBSUMsS0FBS3RGO2dCQUFRRixPQUFPO29CQUFFeUYsT0FBTztvQkFBUUMsUUFBUTtvQkFBUSxHQUFHMUYsS0FBSztnQkFBQzs7Ozs7Ozs7QUFHekU7O0FBRUEsK0RBQWVGLFlBQVlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2NvbXBvbmVudHMvTWFwLnRzeD9jYzAzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmLCBtZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaGVhbHRoY2FyZUNlbnRlcnMsIEhlYWx0aGNhcmVDZW50ZXIgfSBmcm9tICcuLi9kYXRhL2hlYWx0aGNhcmVDZW50ZXJzJztcblxuLy8gRGVmaW5lIHR5cGVzIGZvciBSZXNwb25zZSBhbmQgcHJvcHNcbmludGVyZmFjZSBSZXNwb25zZSB7XG4gIGlkOiBzdHJpbmc7XG4gIGxhdGl0dWRlOiBudW1iZXI7XG4gIGxvbmdpdHVkZTogbnVtYmVyO1xuICByZWFkeV9mb3JfdmFjY2luZT86IHN0cmluZztcbiAgY2FyZXNfZm9yX2dpcmw/OiBib29sZWFuO1xuICByZWNlaXZlZF9ocHZfZG9zZT86IGJvb2xlYW47XG4gIGpvaW5lZF93aGF0c2FwcD86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBNYXBQcm9wcyB7XG4gIHJlc3BvbnNlczogUmVzcG9uc2VbXTtcbiAgc3R5bGU/OiBSZWFjdC5DU1NQcm9wZXJ0aWVzO1xuICBzaG93SGVhbHRoRmFjaWxpdGllcz86IGJvb2xlYW47IC8vIEFkZCBvcHRpb24gdG8gdG9nZ2xlIGZhY2lsaXRpZXNcbn1cblxuLy8gVXNlIG1lbW8gdG8gcHJldmVudCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzXG5jb25zdCBNYXBDb21wb25lbnQgPSBtZW1vKGZ1bmN0aW9uIE1hcENvbXBvbmVudCh7IFxuICByZXNwb25zZXMsIFxuICBzdHlsZSxcbiAgc2hvd0hlYWx0aEZhY2lsaXRpZXMgPSB0cnVlIC8vIERlZmF1bHQgdG8gc2hvd2luZyBmYWNpbGl0aWVzXG59OiBNYXBQcm9wcykge1xuICBjb25zdCBtYXBSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBtYXBJbnN0YW5jZVJlZiA9IHVzZVJlZjxnb29nbGUubWFwcy5NYXAgfCBudWxsPihudWxsKTtcbiAgY29uc3QgbWFya2Vyc1JlZiA9IHVzZVJlZjxnb29nbGUubWFwcy5NYXJrZXJbXT4oW10pO1xuICBjb25zdCBmYWNpbGl0eU1hcmtlcnNSZWYgPSB1c2VSZWY8Z29vZ2xlLm1hcHMuTWFya2VyW10+KFtdKTtcbiAgY29uc3QgaW5pdGlhbFpvb21SZWYgPSB1c2VSZWY8bnVtYmVyPigxMik7XG4gIGNvbnN0IGNlbnRlclJlZiA9IHVzZVJlZjxnb29nbGUubWFwcy5MYXRMbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2luZm9XaW5kb3csIHNldEluZm9XaW5kb3ddID0gdXNlU3RhdGU8Z29vZ2xlLm1hcHMuSW5mb1dpbmRvdyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbc2hvd0hlYWx0aEZhY2lsaXRpZXNTdGF0ZSwgc2V0U2hvd0hlYWx0aEZhY2lsaXRpZXNdID0gdXNlU3RhdGUoc2hvd0hlYWx0aEZhY2lsaXRpZXMpO1xuXG4gIC8vIEluaXRpYWxpemUgbWFwIG9ubHkgb25jZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwUmVmLmN1cnJlbnQgfHwgbWFwSW5zdGFuY2VSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIFxuICAgIGlmICh3aW5kb3cuZ29vZ2xlICYmIHdpbmRvdy5nb29nbGUubWFwcykge1xuICAgICAgY29uc29sZS5sb2coXCJJbml0aWFsaXppbmcgbWFwIGluc3RhbmNlXCIpO1xuICAgICAgY29uc3QgaW5pdGlhbENlbnRlciA9IHsgbGF0OiA4Ljg3LCBsbmc6IDcuMjIgfTsgLy8gQ2VudGVyZWQgb24geW91ciBoZWFsdGhjYXJlIGZhY2lsaXRpZXMgYXJlYVxuICAgICAgY29uc3QgaW5pdGlhbFpvb20gPSAxMjtcbiAgICAgIFxuICAgICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudCA9IG5ldyB3aW5kb3cuZ29vZ2xlLm1hcHMuTWFwKG1hcFJlZi5jdXJyZW50LCB7XG4gICAgICAgIGNlbnRlcjogaW5pdGlhbENlbnRlcixcbiAgICAgICAgem9vbTogaW5pdGlhbFpvb20sXG4gICAgICAgIG1hcFR5cGVJZDogd2luZG93Lmdvb2dsZS5tYXBzLk1hcFR5cGVJZC5ST0FETUFQLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBpbmZvIHdpbmRvdyBpbnN0YW5jZVxuICAgICAgc2V0SW5mb1dpbmRvdyhuZXcgZ29vZ2xlLm1hcHMuSW5mb1dpbmRvdygpKTtcbiAgICAgIFxuICAgICAgLy8gU3RvcmUgaW5pdGlhbCBzZXR0aW5nc1xuICAgICAgaW5pdGlhbFpvb21SZWYuY3VycmVudCA9IGluaXRpYWxab29tO1xuICAgICAgY2VudGVyUmVmLmN1cnJlbnQgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGluaXRpYWxDZW50ZXIubGF0LCBpbml0aWFsQ2VudGVyLmxuZyk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBsaXN0ZW5lcnMgdG8gc3RvcmUgdXNlciBtYXAgaW50ZXJhY3Rpb25zXG4gICAgICBtYXBJbnN0YW5jZVJlZi5jdXJyZW50LmFkZExpc3RlbmVyKCd6b29tX2NoYW5nZWQnLCAoKSA9PiB7XG4gICAgICAgIGlmIChtYXBJbnN0YW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgaW5pdGlhbFpvb21SZWYuY3VycmVudCA9IG1hcEluc3RhbmNlUmVmLmN1cnJlbnQuZ2V0Wm9vbSgpIHx8IGluaXRpYWxab29tO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudC5hZGRMaXN0ZW5lcignY2VudGVyX2NoYW5nZWQnLCAoKSA9PiB7XG4gICAgICAgIGlmIChtYXBJbnN0YW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgY2VudGVyUmVmLmN1cnJlbnQgPSBtYXBJbnN0YW5jZVJlZi5jdXJyZW50LmdldENlbnRlcigpIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIEFkZCBoZWFsdGhjYXJlIGZhY2lsaXRpZXMgdG8gdGhlIG1hcFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwSW5zdGFuY2VSZWYuY3VycmVudCB8fCAhaW5mb1dpbmRvdyB8fCAhc2hvd0hlYWx0aEZhY2lsaXRpZXNTdGF0ZSkgcmV0dXJuO1xuXG4gICAgLy8gQ2xlYXIgZXhpc3RpbmcgZmFjaWxpdHkgbWFya2Vyc1xuICAgIGZhY2lsaXR5TWFya2Vyc1JlZi5jdXJyZW50LmZvckVhY2gobWFya2VyID0+IG1hcmtlci5zZXRNYXAobnVsbCkpO1xuICAgIGZhY2lsaXR5TWFya2Vyc1JlZi5jdXJyZW50ID0gW107XG5cbiAgICAvLyBDdXN0b20gaWNvbiBmb3IgaGVhbHRoY2FyZSBmYWNpbGl0aWVzXG4gICAgY29uc3QgaGVhbHRoRmFjaWxpdHlJY29uID0ge1xuICAgICAgdXJsOiAnL2ltYWdlcy9wdXJwLnBuZycsICAvLyBUaGlzIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhlIHB1YmxpYyBkaXJlY3RvcnlcbiAgICAgIHNjYWxlZFNpemU6IG5ldyBnb29nbGUubWFwcy5TaXplKDMyLCAzMiksICAvLyBBZGp1c3Qgc2l6ZSBhcyBuZWVkZWRcbiAgICB9O1xuXG4gICAgLy8gQWRkIGhlYWx0aGNhcmUgZmFjaWxpdHkgbWFya2Vyc1xuICAgIGhlYWx0aGNhcmVDZW50ZXJzLmZvckVhY2goKGZhY2lsaXR5KSA9PiB7XG4gICAgICBpZiAoZmFjaWxpdHkubGF0aXR1ZGUgJiYgZmFjaWxpdHkubG9uZ2l0dWRlKSB7XG4gICAgICAgIGNvbnN0IG1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoe1xuICAgICAgICAgIHBvc2l0aW9uOiB7IGxhdDogZmFjaWxpdHkubGF0aXR1ZGUsIGxuZzogZmFjaWxpdHkubG9uZ2l0dWRlIH0sXG4gICAgICAgICAgbWFwOiBtYXBJbnN0YW5jZVJlZi5jdXJyZW50LFxuICAgICAgICAgIHRpdGxlOiBmYWNpbGl0eS5uYW1lLFxuICAgICAgICAgIGljb246IGhlYWx0aEZhY2lsaXR5SWNvbixcbiAgICAgICAgICB6SW5kZXg6IDIsIC8vIEhpZ2hlciB6LWluZGV4IHRvIHNob3cgYWJvdmUgcmVzcG9uc2UgbWFya2Vyc1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBjbGljayBsaXN0ZW5lciB0byBzaG93IGluZm8gYWJvdXQgdGhlIGZhY2lsaXR5XG4gICAgICAgIG1hcmtlci5hZGRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGBcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJwYWRkaW5nOiAxMHB4OyBtYXgtd2lkdGg6IDMwMHB4O1wiPlxuICAgICAgICAgICAgICA8aDMgc3R5bGU9XCJtYXJnaW46IDAgMCA4cHggMDtcIj4ke2ZhY2lsaXR5Lm5hbWV9PC9oMz5cbiAgICAgICAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW46IDAgMCA1cHggMDtcIj48c3Ryb25nPkFkZHJlc3M6PC9zdHJvbmc+ICR7ZmFjaWxpdHkuYWRkcmVzc308L3A+XG4gICAgICAgICAgICAgIDxwIHN0eWxlPVwibWFyZ2luOiAwIDAgNXB4IDA7XCI+PHN0cm9uZz5JbW11bml6YXRpb24gRGF5czo8L3N0cm9uZz4gJHtmYWNpbGl0eS5kYXlzX29mX2ltbXVuaXphdGlvbn08L3A+XG4gICAgICAgICAgICAgIDxwIHN0eWxlPVwibWFyZ2luOiAwIDAgNXB4IDA7XCI+PHN0cm9uZz5Ib3Vyczo8L3N0cm9uZz4gJHtmYWNpbGl0eS5ob3Vyc19vZl93b3JrfTwvcD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIGA7XG4gICAgICAgICAgXG4gICAgICAgICAgaW5mb1dpbmRvdy5zZXRDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICAgIGluZm9XaW5kb3cub3BlbihtYXBJbnN0YW5jZVJlZi5jdXJyZW50LCBtYXJrZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGZhY2lsaXR5TWFya2Vyc1JlZi5jdXJyZW50LnB1c2gobWFya2VyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW3Nob3dIZWFsdGhGYWNpbGl0aWVzU3RhdGUsIGluZm9XaW5kb3ddKTsgLy8gT25seSByZS1ydW4gd2hlbiBzaG93SGVhbHRoRmFjaWxpdGllc1N0YXRlIGNoYW5nZXNcblxuICAvLyBIYW5kbGUgcmVzcG9uc2UgbWFya2VycyBzZXBhcmF0ZWx5IHdoZW4gcmVzcG9uc2VzIGNoYW5nZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwSW5zdGFuY2VSZWYuY3VycmVudCB8fCAhcmVzcG9uc2VzIHx8ICFpbmZvV2luZG93KSByZXR1cm47XG5cbiAgICAvLyBDbGVhciBleGlzdGluZyByZXNwb25zZSBtYXJrZXJzXG4gICAgbWFya2Vyc1JlZi5jdXJyZW50LmZvckVhY2gobWFya2VyID0+IG1hcmtlci5zZXRNYXAobnVsbCkpO1xuICAgIG1hcmtlcnNSZWYuY3VycmVudCA9IFtdO1xuXG4gICAgLy8gQWRkIG5ldyByZXNwb25zZSBtYXJrZXJzXG4gICAgcmVzcG9uc2VzLmZvckVhY2gocmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLmxhdGl0dWRlICYmIHJlc3BvbnNlLmxvbmdpdHVkZSkge1xuICAgICAgICAvLyBDcmVhdGUgYSBtYXJrZXIgZm9yIGVhY2ggcmVzcG9uc2VcbiAgICAgICAgY29uc3QgbWFya2VyID0gbmV3IHdpbmRvdy5nb29nbGUubWFwcy5NYXJrZXIoe1xuICAgICAgICAgIHBvc2l0aW9uOiB7IGxhdDogcmVzcG9uc2UubGF0aXR1ZGUsIGxuZzogcmVzcG9uc2UubG9uZ2l0dWRlIH0sXG4gICAgICAgICAgbWFwOiBtYXBJbnN0YW5jZVJlZi5jdXJyZW50LFxuICAgICAgICAgIHRpdGxlOiBgUmVzcG9uc2UgJHtyZXNwb25zZS5pZH1gLFxuICAgICAgICAgIC8vIFVzZSBhIGRpZmZlcmVudCBjb2xvciB0aGFuIGhlYWx0aCBmYWNpbGl0aWVzXG4gICAgICAgICAgaWNvbjoge1xuICAgICAgICAgICAgcGF0aDogZ29vZ2xlLm1hcHMuU3ltYm9sUGF0aC5DSVJDTEUsXG4gICAgICAgICAgICBzY2FsZTogOCxcbiAgICAgICAgICAgIGZpbGxDb2xvcjogXCIjRkY1NzIyXCIsXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogMC44LFxuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiAxLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IFwiI0ZGRkZGRlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB6SW5kZXg6IDEgLy8gTG93ZXIgei1pbmRleCB0aGFuIGhlYWx0aCBmYWNpbGl0aWVzXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIGNsaWNrIGxpc3RlbmVyIHRvIHNob3cgaW5mbyBhYm91dCB0aGUgcmVzcG9uc2VcbiAgICAgICAgbWFya2VyLmFkZExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gYFxuICAgICAgICAgICAgPGRpdiBzdHlsZT1cInBhZGRpbmc6IDEwcHg7IG1heC13aWR0aDogMjAwcHg7XCI+XG4gICAgICAgICAgICAgIDxoNCBzdHlsZT1cIm1hcmdpbjogMCAwIDVweCAwO1wiPlN1cnZleSBSZXNwb25zZSAke3Jlc3BvbnNlLmlkfTwvaDQ+XG4gICAgICAgICAgICAgIDxwIHN0eWxlPVwibWFyZ2luOiAwIDAgM3B4IDA7XCI+UmVhZHkgZm9yIHZhY2NpbmU6ICR7cmVzcG9uc2UucmVhZHlfZm9yX3ZhY2NpbmUgfHwgJ05vdCBzcGVjaWZpZWQnfTwvcD5cbiAgICAgICAgICAgICAgJHtyZXNwb25zZS5jYXJlc19mb3JfZ2lybCA/ICc8cCBzdHlsZT1cIm1hcmdpbjogMCAwIDNweCAwO1wiPkNhcmVzIGZvciBnaXJsOiBZZXM8L3A+JyA6ICcnfVxuICAgICAgICAgICAgICAke3Jlc3BvbnNlLnJlY2VpdmVkX2hwdl9kb3NlID8gJzxwIHN0eWxlPVwibWFyZ2luOiAwIDAgM3B4IDA7XCI+UmVjZWl2ZWQgSFBWIGRvc2U6IFllczwvcD4nIDogJyd9XG4gICAgICAgICAgICAgICR7cmVzcG9uc2Uuam9pbmVkX3doYXRzYXBwID8gJzxwIHN0eWxlPVwibWFyZ2luOiAwIDAgM3B4IDA7XCI+Sm9pbmVkIFdoYXRzQXBwOiBZZXM8L3A+JyA6ICcnfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgYDtcbiAgICAgICAgICBcbiAgICAgICAgICBpbmZvV2luZG93LnNldENvbnRlbnQoY29udGVudCk7XG4gICAgICAgICAgaW5mb1dpbmRvdy5vcGVuKG1hcEluc3RhbmNlUmVmLmN1cnJlbnQsIG1hcmtlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgbWFya2Vyc1JlZi5jdXJyZW50LnB1c2gobWFya2VyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENhbGN1bGF0ZSBib3VuZHMgaW5jbHVkaW5nIGJvdGggcmVzcG9uc2VzIGFuZCB2aXNpYmxlIGhlYWx0aGNhcmUgZmFjaWxpdGllc1xuICAgIGNvbnN0IGFsbFZpc2libGVNYXJrZXJzID0gWy4uLm1hcmtlcnNSZWYuY3VycmVudF07XG4gICAgaWYgKHNob3dIZWFsdGhGYWNpbGl0aWVzU3RhdGUpIHtcbiAgICAgIGFsbFZpc2libGVNYXJrZXJzLnB1c2goLi4uZmFjaWxpdHlNYXJrZXJzUmVmLmN1cnJlbnQpO1xuICAgIH1cblxuICAgIC8vIEFkanVzdCBib3VuZHMgaWYgd2UgaGF2ZSBtdWx0aXBsZSBtYXJrZXJzLCBidXQgbGltaXQgem9vbVxuICAgIGlmIChhbGxWaXNpYmxlTWFya2Vycy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBib3VuZHMgPSBuZXcgd2luZG93Lmdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcygpO1xuICAgICAgYWxsVmlzaWJsZU1hcmtlcnMuZm9yRWFjaChtYXJrZXIgPT4ge1xuICAgICAgICBib3VuZHMuZXh0ZW5kKG1hcmtlci5nZXRQb3NpdGlvbigpIGFzIGdvb2dsZS5tYXBzLkxhdExuZyk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gRml0IGJvdW5kcyBidXQgdGhlbiBjaGVjayBpZiB6b29tIGlzIHRvbyBjbG9zZVxuICAgICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudC5maXRCb3VuZHMoYm91bmRzKTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgZml0Qm91bmRzIHRvIGNvbXBsZXRlIChpdCdzIGFzeW5jKVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChtYXBJbnN0YW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgLy8gSWYgem9vbSBpcyB0b28gY2xvc2UgKGhpZ2hlciBudW1iZXIgPSBjbG9zZXIgem9vbSlcbiAgICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IG1hcEluc3RhbmNlUmVmLmN1cnJlbnQuZ2V0Wm9vbSgpIHx8IDA7XG4gICAgICAgICAgaWYgKGN1cnJlbnRab29tID4gMTUpIHtcbiAgICAgICAgICAgIG1hcEluc3RhbmNlUmVmLmN1cnJlbnQuc2V0Wm9vbSgxNSk7IC8vIFNldCBhIG1heGltdW0gem9vbSBsZXZlbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgMTAwKTtcbiAgICB9IFxuICAgIC8vIElmIG9ubHkgb25lIG1hcmtlclxuICAgIGVsc2UgaWYgKGFsbFZpc2libGVNYXJrZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gRm9yIGEgc2luZ2xlIG1hcmtlciwgY2VudGVyIGJ1dCB1c2UgYSBmaXhlZCB6b29tXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGFsbFZpc2libGVNYXJrZXJzWzBdLmdldFBvc2l0aW9uKCk7XG4gICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudC5zZXRDZW50ZXIocG9zaXRpb24pO1xuICAgICAgICBtYXBJbnN0YW5jZVJlZi5jdXJyZW50LnNldFpvb20oMTQpOyAvLyBHb29kIHpvb20gbGV2ZWwgZm9yIGEgc2luZ2xlIHBvaW50XG4gICAgICB9XG4gICAgfSBcbiAgICAvLyBJZiBubyBtYXJrZXJzLCByZXR1cm4gdG8gb3JpZ2luYWwgdmlld1xuICAgIGVsc2UgaWYgKGFsbFZpc2libGVNYXJrZXJzLmxlbmd0aCA9PT0gMCAmJiBjZW50ZXJSZWYuY3VycmVudCkge1xuICAgICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudC5zZXRDZW50ZXIoY2VudGVyUmVmLmN1cnJlbnQpO1xuICAgICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudC5zZXRab29tKGluaXRpYWxab29tUmVmLmN1cnJlbnQpO1xuICAgIH1cbiAgfSwgW3Jlc3BvbnNlcywgc2hvd0hlYWx0aEZhY2lsaXRpZXNTdGF0ZSwgaW5mb1dpbmRvd10pO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxGaWx0ZXJCdXR0b25OZXdcbiAgICAgICAgYWN0aXZlPXtzaG93SGVhbHRoRmFjaWxpdGllc1N0YXRlfVxuICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTaG93SGVhbHRoRmFjaWxpdGllcyghc2hvd0hlYWx0aEZhY2lsaXRpZXNTdGF0ZSl9XG4gICAgICAgIGNvdW50PXtoZWFsdGhjYXJlQ2VudGVycy5sZW5ndGh9XG4gICAgICAgIGxhYmVsPXtgJHtzaG93SGVhbHRoRmFjaWxpdGllc1N0YXRlID8gJ0hpZGUnIDogJ1Nob3cnfSBIZWFsdGggRmFjaWxpdGllc2B9XG4gICAgICAvPlxuICAgICAgPGRpdiByZWY9e21hcFJlZn0gc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScsIC4uLnN0eWxlIH19IC8+XG4gICAgPC8+XG4gICk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwQ29tcG9uZW50O1xuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwibWVtbyIsImhlYWx0aGNhcmVDZW50ZXJzIiwiTWFwQ29tcG9uZW50IiwicmVzcG9uc2VzIiwic3R5bGUiLCJzaG93SGVhbHRoRmFjaWxpdGllcyIsIm1hcFJlZiIsIm1hcEluc3RhbmNlUmVmIiwibWFya2Vyc1JlZiIsImZhY2lsaXR5TWFya2Vyc1JlZiIsImluaXRpYWxab29tUmVmIiwiY2VudGVyUmVmIiwiaW5mb1dpbmRvdyIsInNldEluZm9XaW5kb3ciLCJzaG93SGVhbHRoRmFjaWxpdGllc1N0YXRlIiwic2V0U2hvd0hlYWx0aEZhY2lsaXRpZXMiLCJjdXJyZW50Iiwid2luZG93IiwiZ29vZ2xlIiwibWFwcyIsImNvbnNvbGUiLCJsb2ciLCJpbml0aWFsQ2VudGVyIiwibGF0IiwibG5nIiwiaW5pdGlhbFpvb20iLCJNYXAiLCJjZW50ZXIiLCJ6b29tIiwibWFwVHlwZUlkIiwiTWFwVHlwZUlkIiwiUk9BRE1BUCIsIkluZm9XaW5kb3ciLCJMYXRMbmciLCJhZGRMaXN0ZW5lciIsImdldFpvb20iLCJnZXRDZW50ZXIiLCJmb3JFYWNoIiwibWFya2VyIiwic2V0TWFwIiwiaGVhbHRoRmFjaWxpdHlJY29uIiwidXJsIiwic2NhbGVkU2l6ZSIsIlNpemUiLCJmYWNpbGl0eSIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiTWFya2VyIiwicG9zaXRpb24iLCJtYXAiLCJ0aXRsZSIsIm5hbWUiLCJpY29uIiwiekluZGV4IiwiY29udGVudCIsImFkZHJlc3MiLCJkYXlzX29mX2ltbXVuaXphdGlvbiIsImhvdXJzX29mX3dvcmsiLCJzZXRDb250ZW50Iiwib3BlbiIsInB1c2giLCJyZXNwb25zZSIsImlkIiwicGF0aCIsIlN5bWJvbFBhdGgiLCJDSVJDTEUiLCJzY2FsZSIsImZpbGxDb2xvciIsImZpbGxPcGFjaXR5Iiwic3Ryb2tlV2VpZ2h0Iiwic3Ryb2tlQ29sb3IiLCJyZWFkeV9mb3JfdmFjY2luZSIsImNhcmVzX2Zvcl9naXJsIiwicmVjZWl2ZWRfaHB2X2Rvc2UiLCJqb2luZWRfd2hhdHNhcHAiLCJhbGxWaXNpYmxlTWFya2VycyIsImxlbmd0aCIsImJvdW5kcyIsIkxhdExuZ0JvdW5kcyIsImV4dGVuZCIsImdldFBvc2l0aW9uIiwiZml0Qm91bmRzIiwic2V0VGltZW91dCIsImN1cnJlbnRab29tIiwic2V0Wm9vbSIsInNldENlbnRlciIsIkZpbHRlckJ1dHRvbk5ldyIsImFjdGl2ZSIsIm9uQ2xpY2siLCJjb3VudCIsImxhYmVsIiwiZGl2IiwicmVmIiwid2lkdGgiLCJoZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/Map.tsx\n"));

/***/ })

});